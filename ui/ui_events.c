// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.0
// LVGL version: 8.3.6
// Project name: SquareLine_Project

#include "ui.h"
#include <stdio.h>
#include <time.h>
#include <esp_log.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/portmacro.h>
#include <esp_sntp.h>

#include "wifi.h"

//////////////////// DEFINITIONS ////////////////////
#define WIFI_CONNECTION_TIMEOUT pdMS_TO_TICKS(30000)  // 30秒超时时间

//////////////////// GLOBAL VARIABLES ////////////////////

// 全局变量用于存储日月时分的时间戳
time_t globalTime = 0;
lv_obj_t * currentTimeLabel;

//////////////////// STATIC FUNCTION DECLARATIONS ////////////////////

static void updateCurrentTimeLabel(void);
static void obtainTime(void* pvParameter);
static void updateTimeTask(void *pvParameter);
static void initTimeTask(void *param);

//////////////////// 不给lvgl事件直接调用的 ////////////////////

// 把globalTime更新到currentTimeLabel上
static void updateCurrentTimeLabel(void) {
    struct tm timeinfo;
    char timeStr[9];

    localtime_r(&globalTime, &timeinfo);
    strftime(timeStr, sizeof(timeStr), "%H:%M:%S", &timeinfo);
    lv_label_set_text(currentTimeLabel, timeStr);
}
// 从NTP获取时间
static void obtainTime(void* pvParameter)
{
    // NTP服务器列表, 这是macOS上使用ntpdate测试出的一些延迟低的服务器, 2024.5.15
    const char* ntp_servers[] = {
        "cn.ntp.org.cn",
        // "edu.ntp.org.cn",
        // "ntp.sjtu.edu.cn",
        // "ntp.aliyun.com",
        // "pool.ntp.org",
    };
    const int num_ntp_servers = sizeof(ntp_servers) / sizeof(ntp_servers[0]);

    time_t now = 0;
    struct tm timeinfo = { 0 };
    int retry = 0;
    const int retry_count = 10;

    esp_sntp_setoperatingmode(SNTP_OPMODE_POLL);
    for (int i = 0; i < num_ntp_servers; ++i) {
        esp_sntp_setservername(i, ntp_servers[i]);
    }
    esp_sntp_init();

    while (timeinfo.tm_year < (2016 - 1900) && ++retry < retry_count) {
        ESP_LOGI("obtainTime", "等待系统时间设置... (%d/%d) 正在尝试连接服务器: %s", retry, retry_count, ntp_servers[retry % num_ntp_servers]);

        time(&now);
        vTaskDelay(2000 / portTICK_PERIOD_MS);
        localtime_r(&now, &timeinfo);
    }

    if (retry >= retry_count) {
        ESP_LOGE("obtainTime", "在 %d 次重试后无法获取时间。请检查您的网络连接。", retry_count);
    } else {
        ESP_LOGI("obtainTime", "系统时间已设置。");
        // 修正时区
        timeinfo.tm_hour += 8;
        mktime(&timeinfo);
        // 保存全局时间
        globalTime = mktime(&timeinfo);
    }
    // 启动定时器
    xTaskCreate(updateTimeTask, "updateTimeTask", 2048, NULL, 5, NULL);
    vTaskDelete(NULL);
}
// 时间更新定时器
static void updateTimeTask(void *pvParameter)
{
    while (1)
    {
        updateCurrentTimeLabel();
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        globalTime += 1;
    }
}
// 初始化时间任务
static void initTimeTask(void *param)
{
    EventGroupHandle_t wifi_event_group = get_wifi_event_group();
    EventBits_t bits = xEventGroupWaitBits(wifi_event_group, WIFI_CONNECTED_BIT, pdFALSE, pdTRUE, WIFI_CONNECTION_TIMEOUT);
    if (bits & WIFI_CONNECTED_BIT) {
        ESP_LOGI("initTimeTask", "Wi-Fi 已连接");
        // 异步, 否则会阻塞UI线程
        xTaskCreate(obtainTime, "obtainTime", 4096, NULL, 5, NULL);
    } else {
        ESP_LOGE("initTimeTask", "Wi-Fi 未连接");
    }
    vTaskDelete(NULL); // 删除任务
}


//////////////////// 给lvgl的事件用的回调 //////////////////// 

// initial actions
void initTime(lv_event_t * e)
{
    // 在初始化时间时把默认显示时间的label设置为主界面的, 否则currentTimeLabel为空很危险
    currentTimeLabel = ui_Header_Main_Time;
    // 因为要等待WiFi连接才能开始获取事件, 所以创建异步任务, 否则会阻塞界面加载
    xTaskCreate(initTimeTask, "initTimeTask", 4096, NULL, 5, NULL);
}

// 由各个screen loaded时调用
void setTimeMain(lv_event_t * e)
{
    currentTimeLabel = ui_Header_Main_Time;
    // 本来只有主界面要加这个防止时间未初始化就更新值, 但是用户有可能会在时间未初始化时乱点点到别的界面, 所以每个界面都加上了
    if(globalTime > 0)
        updateCurrentTimeLabel();
}
void setTimeMusic(lv_event_t * e)
{
    currentTimeLabel = ui_Header_Music_Time;
    if(globalTime > 0)
        updateCurrentTimeLabel();
}

void setTimeNatureSound(lv_event_t * e)
{
    // currentTimeLabel = ui_Header_Nature_Sound_Time
    if(globalTime > 0)
        updateCurrentTimeLabel();
}

void setTimeBluetooth(lv_event_t * e)
{
    // currentTimeLabel = ui_Header_Bluetooth_Time2
    if(globalTime > 0)
        updateCurrentTimeLabel();
}

void setTimeMode(lv_event_t * e)
{
    currentTimeLabel = ui_Header_Music_Time;
    if(globalTime > 0)
        updateCurrentTimeLabel();
}

void setTimeWakeup(lv_event_t * e)
{
    currentTimeLabel = ui_Header_Music_Time;
    if(globalTime > 0)
        updateCurrentTimeLabel();
}
